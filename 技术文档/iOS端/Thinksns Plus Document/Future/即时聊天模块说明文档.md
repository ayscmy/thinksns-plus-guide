2019年07月18日11:41:59

即时聊天用的环信SDK,聊天界面集成环信EaseUI,特别说明如下:

# 结构

结构图如图:

![即时聊天结构图](./image/即时聊天结构图.png)
后续会替换成详细的UML图

## 类说明:

会话列表页面控制器:[TSChatListTableViewController](#会话页面)
会话详情页面控制器:[ChatDetailViewController](#会话页面)
网络请求管理:[参考环信开发文档](#网络请求管理)
推送服务: 需要在 AppDeleguate.plist 中配置推送证书名称,参数apnsCertName: 推送证书名（不需要加后缀） SDK注册 APNS文件的名字, 需要与后台上传证书时的名字一一对应,不需要推送可不配置
发起聊天: 发起聊天的类较多,不一一举例
# 会话页面

聊天视图部分基于[环信EaseUI ]构建视图相关逻辑,环信EaseUI,环信EaseUI中 用的MWPhotoBrowse,图片处理库,浏览显示,MJRefresh用于刷新,MBProgressHUD,用户提示加载刷新,三个框架比较老,二次开发需要注意兼容.
## 目录结构

```shell
.
├── Model
│   └── EMConversation+TSMessage.m
├── View
│   ├── TSGroupNewOwnerCell.swift
│   ├── TSConversationTableViewCell.swift
│   └── TSConversationTableViewCell.xib
├── TSChatListTableViewController.swift
└── ChatDetailViewController.swift

```
## 主要类及示例代码

`方法getHyPassword()`负责获取环信登录密码,环信的登录是通过TS+服务器登录和注册的,连接失败,会自动重连,聊天是否能用,可以重点关注这个方法,如果返回失败的信息,说明环信配置有问题,需要检查后台配置环信正确与否,app端需要检查AppEnvironment.plist 环信配置信息,环信未付费只能注册100个,以后注册就会失败(特别提示)
`getChatName(conver: EMConversation) -> String`获取显示的昵称(单聊&&群聊),环信不提供昵称和头像,需要从TS+服务器获取.

### 控制器获取环信会话列表

示例代码:

```swift
// MARK: - 获取环信会话列表
@objc func getHyChatList() {
if EMClient.shared().isConnected == false {
self.reconnectionTSHYIMService()
return
}
if !EMClient.shared().isLoggedIn {
self.reconnectionTSHYIMService()
copyTableView?.isHidden = true
tableView.isHidden = false
if tableView.mj_header.isRefreshing {
tableView.mj_header.endRefreshing()
}
} else {
let globalQueueDefault = DispatchQueue.global()
globalQueueDefault.async {
var resultError: EMError? = nil
var myGroup = NSArray()
if let hyOnlineGroup = EMClient.shared().groupManager.getJoinedGroupsFromServer(withPage: 0, pageSize: -1, error: &resultError) {
myGroup = hyOnlineGroup as NSArray
} else {
// 有可能是在其他设备上登录了该账号
}
self.groupArray.removeAllObjects()
self.groupArray.addObjects(from: myGroup as! [Any])
var conversations = NSArray()
if let hyOnlineConversations = EMClient.shared().chatManager.getAllConversations() {
conversations = hyOnlineConversations as NSArray
}
self.conversationArray.removeAllObjects()
self.conversationArray.addObjects(from: conversations as! [Any])

/// tempIndexArray里面装的是群聊数据在conversationArray数组里面的位置,存在的群会话
/// 需要请求群信息的群id
var groupIDs: [String] = []
let enableGroups = NSMutableArray()
if self.groupArray.count != 0 && self.conversationArray.count != 0 {
for itemCon in self.conversationArray {
let itemCon = itemCon as! EMConversation
if itemCon.type == EMConversationTypeGroupChat {
for itemGroup in self.groupArray {
let itemGroup = itemGroup as! EMGroup
if itemGroup.groupId == itemCon.conversationId {
enableGroups.add(itemGroup)
groupIDs.append(itemGroup.groupId)
// 设置是否被屏蔽消息
itemCon.isBlocked = itemGroup.isBlocked
break
}
}
}
}
}
self.groupArray = enableGroups
if groupIDs.isEmpty == true {
/// 没有群组会话，就不请求群信息
DispatchQueue.main.async {
self.updataHyChatList()
}
return
}
// 当前没有群信息且有缓存的群信息就先显示在页面上，稍后网络更新完成后再更新
let patch = NSHomeDirectory() + "/Documents/groupInfo.data"
let getData = FileManager.default.contents(atPath: patch)
if self.groupInfoDic.count == 0 && getData != nil, let dataDic = try? JSONSerialization.jsonObject(with: getData!, options: .mutableContainers)  as? NSDictionary {
// 将群信息绑定到会话中
self.groupInfoDic = NSMutableDictionary(dictionary: dataDic!)
for (_, itemCon) in self.conversationArray.enumerated().reversed() {
if let conversation = itemCon as? EMConversation {
if let groupInfo = self.groupInfoDic[conversation.conversationId] {
conversation.groupInfo = groupInfo as! [AnyHashable : Any]
}
}
}
self.updataHyChatList()
}
self.getChatGroupsInfo(groupIDs: groupIDs, isInit: true)
}
}
}
```
```swift
// MARK: - 发起聊天参考代码(部分)
let idSt:(用户ID)
let vc = (聊天详细界面)ChatDetailViewController(conversationChatter: idSt, conversationType:EMConversationTypeChat(聊天类型))
vc?.chatTitle = groupModel.founder?.name(聊天界面标题)
navigationController?.pushViewController(vc!, animated: true)
```

